/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_aframe_click_drag_component__ = __webpack_require__(/*! aframe-click-drag-component */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_aframe_click_drag_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_aframe_click_drag_component__);\n\n__WEBPACK_IMPORTED_MODULE_0_aframe_click_drag_component___default()(window.AFRAME);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL21haW4uanM/N2EyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVnaXN0ZXJDbGlja0RyYWcgZnJvbSAnYWZyYW1lLWNsaWNrLWRyYWctY29tcG9uZW50JztcbnJlZ2lzdGVyQ2xpY2tEcmFnKHdpbmRvdy5BRlJBTUUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***************************************************************!*\
  !*** ./node_modules/aframe-click-drag-component/lib/index.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = aframeDraggableComponent;\n\nvar _deepEqual = __webpack_require__(/*! deep-equal */ 2);\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar COMPONENT_NAME = 'click-drag';\nvar DRAG_START_EVENT = 'dragstart';\nvar DRAG_MOVE_EVENT = 'dragmove';\nvar DRAG_END_EVENT = 'dragend';\n\nvar TIME_TO_KEEP_LOG = 100;\n\nfunction forceWorldUpdate(threeElement) {\n\n  var element = threeElement;\n  while (element.parent) {\n    element = element.parent;\n  }\n\n  element.updateMatrixWorld(true);\n}\n\nfunction forEachParent(element, lambda) {\n  while (element.attachedToParent) {\n    element = element.parentElement;\n    lambda(element);\n  }\n}\n\nfunction someParent(element, lambda) {\n  while (element.attachedToParent) {\n    element = element.parentElement;\n    if (lambda(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction cameraPositionToVec3(camera, vec3) {\n\n  vec3.set(camera.components.position.data.x, camera.components.position.data.y, camera.components.position.data.z);\n\n  forEachParent(camera, function (element) {\n\n    if (element.components && element.components.position) {\n      vec3.set(vec3.x + element.components.position.data.x, vec3.y + element.components.position.data.y, vec3.z + element.components.position.data.z);\n    }\n  });\n}\n\nfunction localToWorld(THREE, threeCamera, vector) {\n  forceWorldUpdate(threeCamera);\n  return threeCamera.localToWorld(vector);\n}\n\nvar _ref = function unprojectFunction() {\n\n  var initialized = false;\n\n  var matrix = void 0;\n\n  function initialize(THREE) {\n    matrix = new THREE.Matrix4();\n\n    return true;\n  }\n\n  return {\n    unproject: function unproject(THREE, vector, camera) {\n\n      var threeCamera = camera.components.camera.camera;\n\n      initialized = initialized || initialize(THREE);\n\n      vector.applyProjection(matrix.getInverse(threeCamera.projectionMatrix));\n\n      return localToWorld(THREE, threeCamera, vector);\n    }\n  };\n}(),\n    unproject = _ref.unproject;\n\nfunction clientCoordsTo3DCanvasCoords(clientX, clientY, offsetX, offsetY, clientWidth, clientHeight) {\n  return {\n    x: (clientX - offsetX) / clientWidth * 2 - 1,\n    y: -((clientY - offsetY) / clientHeight) * 2 + 1\n  };\n}\n\nvar _ref2 = function screenCoordsToDirectionFunction() {\n\n  var initialized = false;\n\n  var mousePosAsVec3 = void 0;\n  var cameraPosAsVec3 = void 0;\n\n  function initialize(THREE) {\n    mousePosAsVec3 = new THREE.Vector3();\n    cameraPosAsVec3 = new THREE.Vector3();\n\n    return true;\n  }\n\n  return {\n    screenCoordsToDirection: function screenCoordsToDirection(THREE, aframeCamera, _ref3) {\n      var clientX = _ref3.x,\n          clientY = _ref3.y;\n\n\n      initialized = initialized || initialize(THREE);\n\n      // scale mouse coordinates down to -1 <-> +1\n\n      var _clientCoordsTo3DCanv = clientCoordsTo3DCanvasCoords(clientX, clientY, 0, 0, // TODO: Replace with canvas position\n      window.innerWidth, window.innerHeight),\n          mouseX = _clientCoordsTo3DCanv.x,\n          mouseY = _clientCoordsTo3DCanv.y;\n\n      mousePosAsVec3.set(mouseX, mouseY, -1);\n\n      // apply camera transformation from near-plane of mouse x/y into 3d space\n      // NOTE: This should be replaced with THREE code directly once the aframe bug\n      // is fixed:\n      /*\n            cameraPositionToVec3(aframeCamera, cameraPosAsVec3);\n            const {x, y, z} = new THREE\n             .Vector3(mouseX, mouseY, -1)\n             .unproject(aframeCamera.components.camera.camera)\n             .sub(cameraPosAsVec3)\n             .normalize();\n      */\n      var projectedVector = unproject(THREE, mousePosAsVec3, aframeCamera);\n\n      cameraPositionToVec3(aframeCamera, cameraPosAsVec3);\n\n      // Get the unit length direction vector from the camera's position\n\n      var _projectedVector$sub$ = projectedVector.sub(cameraPosAsVec3).normalize(),\n          x = _projectedVector$sub$.x,\n          y = _projectedVector$sub$.y,\n          z = _projectedVector$sub$.z;\n\n      return { x: x, y: y, z: z };\n    }\n  };\n}(),\n    screenCoordsToDirection = _ref2.screenCoordsToDirection;\n\n/**\n * @param planeNormal {THREE.Vector3}\n * @param planeConstant {Float} Distance from origin of the plane\n * @param rayDirection {THREE.Vector3} Direction of ray from the origin\n *\n * @return {THREE.Vector3} The intersection point of the ray and plane\n */\n\n\nfunction rayPlaneIntersection(planeNormal, planeConstant, rayDirection) {\n  // A line from the camera position toward (and through) the plane\n  var distanceToPlane = planeConstant / planeNormal.dot(rayDirection);\n  return rayDirection.multiplyScalar(distanceToPlane);\n}\n\nvar _ref4 = function directionToWorldCoordsFunction() {\n\n  var initialized = false;\n\n  var direction = void 0;\n  var cameraPosAsVec3 = void 0;\n\n  function initialize(THREE) {\n    direction = new THREE.Vector3();\n    cameraPosAsVec3 = new THREE.Vector3();\n\n    return true;\n  }\n\n  return {\n    /**\n     * @param camera Three.js Camera instance\n     * @param Object Position of the camera\n     * @param Object position of the mouse (scaled to be between -1 to 1)\n     * @param depth Depth into the screen to calculate world coordinates for\n     */\n    directionToWorldCoords: function directionToWorldCoords(THREE, aframeCamera, camera, _ref5, depth) {\n      var directionX = _ref5.x,\n          directionY = _ref5.y,\n          directionZ = _ref5.z;\n\n\n      initialized = initialized || initialize(THREE);\n\n      cameraPositionToVec3(aframeCamera, cameraPosAsVec3);\n      direction.set(directionX, directionY, directionZ);\n\n      // A line from the camera position toward (and through) the plane\n      var newPosition = rayPlaneIntersection(camera.getWorldDirection(), depth, direction);\n\n      // Reposition back to the camera position\n\n      var _newPosition$add = newPosition.add(cameraPosAsVec3),\n          x = _newPosition$add.x,\n          y = _newPosition$add.y,\n          z = _newPosition$add.z;\n\n      return { x: x, y: y, z: z };\n    }\n  };\n}(),\n    directionToWorldCoords = _ref4.directionToWorldCoords;\n\nvar _ref6 = function selectItemFunction() {\n\n  var initialized = false;\n\n  var cameraPosAsVec3 = void 0;\n  var directionAsVec3 = void 0;\n  var raycaster = void 0;\n  var plane = void 0;\n\n  function initialize(THREE) {\n    plane = new THREE.Plane();\n    cameraPosAsVec3 = new THREE.Vector3();\n    directionAsVec3 = new THREE.Vector3();\n    raycaster = new THREE.Raycaster();\n\n    // TODO: From camera values?\n    raycaster.far = Infinity;\n    raycaster.near = 0;\n\n    return true;\n  }\n\n  return {\n    selectItem: function selectItem(THREE, selector, camera, clientX, clientY) {\n\n      initialized = initialized || initialize(THREE);\n\n      var _screenCoordsToDirect = screenCoordsToDirection(THREE, camera, { x: clientX, y: clientY }),\n          directionX = _screenCoordsToDirect.x,\n          directionY = _screenCoordsToDirect.y,\n          directionZ = _screenCoordsToDirect.z;\n\n      cameraPositionToVec3(camera, cameraPosAsVec3);\n      directionAsVec3.set(directionX, directionY, directionZ);\n\n      raycaster.set(cameraPosAsVec3, directionAsVec3);\n\n      // Push meshes onto list of objects to intersect.\n      // TODO: Can we do this at some other point instead of every time a ray is\n      // cast? Is that a micro optimization?\n      var objects = Array.from(camera.sceneEl.querySelectorAll('[' + selector + ']')).map(function (object) {\n        return object.object3D;\n      });\n\n      var recursive = true;\n\n      var intersected = raycaster.intersectObjects(objects, recursive)\n      // Only keep intersections against objects that have a reference to an entity.\n      .filter(function (intersection) {\n        return !!intersection.object.el;\n      })\n      // Only keep ones that are visible\n      .filter(function (intersection) {\n        return intersection.object.parent.visible;\n      })\n      // The first element is the closest\n      [0]; // eslint-disable-line no-unexpected-multiline\n\n      if (!intersected) {\n        return {};\n      }\n\n      var point = intersected.point,\n          object = intersected.object;\n\n      // Aligned to the world direction of the camera\n      // At the specified intersection point\n\n      plane.setFromNormalAndCoplanarPoint(camera.components.camera.camera.getWorldDirection().clone().negate(), point.clone().sub(cameraPosAsVec3));\n\n      var depth = plane.constant;\n\n      var offset = point.sub(object.getWorldPosition());\n\n      return { depth: depth, offset: offset, element: object.el };\n    }\n  };\n}(),\n    selectItem = _ref6.selectItem;\n\nfunction dragItem(THREE, element, offset, camera, depth, mouseInfo) {\n\n  var threeCamera = camera.components.camera.camera;\n\n  // Setting up for rotation calculations\n  var startCameraRotationInverse = threeCamera.getWorldQuaternion().inverse();\n  var startElementRotation = element.object3D.getWorldQuaternion();\n  var elementRotationOrder = element.object3D.rotation.order;\n\n  var rotationQuaternion = new THREE.Quaternion();\n  var rotationEuler = element.object3D.rotation.clone();\n\n  var offsetVector = new THREE.Vector3(offset.x, offset.y, offset.z);\n  var lastMouseInfo = mouseInfo;\n\n  var nextRotation = {\n    x: THREE.Math.radToDeg(rotationEuler.x),\n    y: THREE.Math.radToDeg(rotationEuler.y),\n    z: THREE.Math.radToDeg(rotationEuler.z)\n  };\n\n  var activeCamera = element.sceneEl.systems.camera.activeCameraEl;\n\n  var isChildOfActiveCamera = someParent(element, function (parent) {\n    return parent === activeCamera;\n  });\n\n  function onMouseMove(_ref7) {\n    var clientX = _ref7.clientX,\n        clientY = _ref7.clientY;\n\n\n    lastMouseInfo = { clientX: clientX, clientY: clientY };\n\n    var direction = screenCoordsToDirection(THREE, camera, { x: clientX, y: clientY });\n\n    var _directionToWorldCoor = directionToWorldCoords(THREE, camera, camera.components.camera.camera, direction, depth),\n        x = _directionToWorldCoor.x,\n        y = _directionToWorldCoor.y,\n        z = _directionToWorldCoor.z;\n\n    var rotationDiff = void 0;\n\n    // Start by rotating backwards from the initial camera rotation\n    rotationDiff = rotationQuaternion.copy(startCameraRotationInverse);\n\n    // rotate the offset\n    offsetVector.set(offset.x, offset.y, offset.z);\n\n    // Then add the current camera rotation\n    rotationDiff = rotationQuaternion.multiply(threeCamera.getWorldQuaternion());\n\n    offsetVector.applyQuaternion(rotationDiff);\n\n    if (!isChildOfActiveCamera) {\n      // And correctly offset rotation\n      rotationDiff.multiply(startElementRotation);\n\n      rotationEuler.setFromQuaternion(rotationDiff, elementRotationOrder);\n    }\n\n    nextRotation.x = THREE.Math.radToDeg(rotationEuler.x);\n    nextRotation.y = THREE.Math.radToDeg(rotationEuler.y);\n    nextRotation.z = THREE.Math.radToDeg(rotationEuler.z);\n\n    var nextPosition = { x: x - offsetVector.x, y: y - offsetVector.y, z: z - offsetVector.z };\n\n    // When the element has parents, we need to convert its new world position\n    // into new local position of its parent element\n    if (element.parentEl !== element.sceneEl) {\n\n      // The new world position\n      offsetVector.set(nextPosition.x, nextPosition.y, nextPosition.z);\n\n      // Converted\n      element.parentEl.object3D.worldToLocal(offsetVector);\n\n      nextPosition.x = offsetVector.x;\n      nextPosition.y = offsetVector.y;\n      nextPosition.z = offsetVector.z;\n    }\n\n    element.emit(DRAG_MOVE_EVENT, { nextPosition: nextPosition, nextRotation: nextRotation, clientX: clientX, clientY: clientY });\n\n    element.setAttribute('position', nextPosition);\n\n    element.setAttribute('rotation', nextRotation);\n  }\n\n  function onTouchMove(_ref8) {\n    var _ref8$changedTouches = _slicedToArray(_ref8.changedTouches, 1),\n        touchInfo = _ref8$changedTouches[0];\n\n    onMouseMove(touchInfo);\n  }\n\n  function onCameraChange(_ref9) {\n    var detail = _ref9.detail;\n\n    if ((detail.name === 'position' || detail.name === 'rotation') && !(0, _deepEqual2.default)(detail.oldData, detail.newData)) {\n      onMouseMove(lastMouseInfo);\n    }\n  }\n\n  document.addEventListener('mousemove', onMouseMove);\n  document.addEventListener('touchmove', onTouchMove);\n  camera.addEventListener('componentchanged', onCameraChange);\n\n  // The \"unlisten\" function\n  return function (_) {\n    document.removeEventListener('mousemove', onMouseMove);\n    document.removeEventListener('touchmove', onTouchMove);\n    camera.removeEventListener('componentchanged', onCameraChange);\n  };\n}\n\n// Closure to close over the removal of the event listeners\n\nvar _ref10 = function getDidMountAndUnmount() {\n\n  var removeClickListeners = void 0;\n  var removeDragListeners = void 0;\n  var cache = [];\n\n  function initialize(THREE, componentName) {\n\n    // TODO: Based on a scene from the element passed in?\n    var scene = document.querySelector('a-scene');\n    // delay loading of this as we're not 100% if the scene has loaded yet or not\n    var camera = void 0;\n    var draggedElement = void 0;\n    var dragInfo = void 0;\n    var positionLog = [];\n\n    function cleanUpPositionLog() {\n      var now = performance.now();\n      while (positionLog.length && now - positionLog[0].time > TIME_TO_KEEP_LOG) {\n        // remove the first element;\n        positionLog.shift();\n      }\n    }\n\n    function onDragged(_ref11) {\n      var nextPosition = _ref11.detail.nextPosition;\n\n      // Continuously clean up so we don't get huge logs built up\n      cleanUpPositionLog();\n      positionLog.push({\n        position: Object.assign({}, nextPosition),\n        time: performance.now()\n      });\n    }\n\n    function onMouseDown(_ref12) {\n      var clientX = _ref12.clientX,\n          clientY = _ref12.clientY;\n\n      var _selectItem = selectItem(THREE, componentName, camera, clientX, clientY),\n          depth = _selectItem.depth,\n          offset = _selectItem.offset,\n          element = _selectItem.element;\n\n      if (element) {\n        (function () {\n          // Can only drag one item at a time, so no need to check if any\n          // listener is already set up\n          var removeDragItemListeners = dragItem(THREE, element, offset, camera, depth, {\n            clientX: clientX,\n            clientY: clientY\n          });\n\n          draggedElement = element;\n\n          dragInfo = {\n            offset: { x: offset.x, y: offset.y, z: offset.z },\n            depth: depth,\n            clientX: clientX,\n            clientY: clientY\n          };\n\n          element.addEventListener(DRAG_MOVE_EVENT, onDragged);\n\n          removeDragListeners = function removeDragListeners(_) {\n            element.removeEventListener(DRAG_MOVE_EVENT, onDragged);\n            // eslint-disable-next-line no-unused-expressions\n            removeDragItemListeners && removeDragItemListeners();\n            // in case this removal function gets called more than once\n            removeDragItemListeners = null;\n          };\n\n          element.emit(DRAG_START_EVENT, dragInfo);\n        })();\n      }\n    }\n\n    function calculateVelocity() {\n\n      if (positionLog.length < 2) {\n        return 0;\n      }\n\n      var start = positionLog[positionLog.length - 1];\n      var end = positionLog[0];\n\n      var deltaTime = 1000 / (start.time - end.time);\n      return {\n        x: (start.position.x - end.position.x) * deltaTime, // m/s\n        y: (start.position.y - end.position.y) * deltaTime, // m/s\n        z: (start.position.z - end.position.z) * deltaTime };\n    }\n\n    function onMouseUp(_ref13) {\n      var clientX = _ref13.clientX,\n          clientY = _ref13.clientY;\n\n\n      if (!draggedElement) {\n        return;\n      }\n\n      cleanUpPositionLog();\n\n      var velocity = calculateVelocity();\n\n      draggedElement.emit(DRAG_END_EVENT, Object.assign({}, dragInfo, { clientX: clientX, clientY: clientY, velocity: velocity }));\n\n      removeDragListeners && removeDragListeners(); // eslint-disable-line no-unused-expressions\n      removeDragListeners = undefined;\n    }\n\n    function onTouchStart(_ref14) {\n      var _ref14$changedTouches = _slicedToArray(_ref14.changedTouches, 1),\n          touchInfo = _ref14$changedTouches[0];\n\n      onMouseDown(touchInfo);\n    }\n\n    function onTouchEnd(_ref15) {\n      var _ref15$changedTouches = _slicedToArray(_ref15.changedTouches, 1),\n          touchInfo = _ref15$changedTouches[0];\n\n      onMouseUp(touchInfo);\n    }\n\n    function run() {\n\n      camera = scene.camera.el;\n\n      // TODO: Attach to canvas?\n      document.addEventListener('mousedown', onMouseDown);\n      document.addEventListener('mouseup', onMouseUp);\n\n      document.addEventListener('touchstart', onTouchStart);\n      document.addEventListener('touchend', onTouchEnd);\n\n      removeClickListeners = function removeClickListeners(_) {\n        document.removeEventListener('mousedown', onMouseDown);\n        document.removeEventListener('mouseup', onMouseUp);\n\n        document.removeEventListener('touchstart', onTouchStart);\n        document.removeEventListener('touchend', onTouchEnd);\n      };\n    }\n\n    if (scene.hasLoaded) {\n      run();\n    } else {\n      scene.addEventListener('loaded', run);\n    }\n  }\n\n  function tearDown() {\n    removeClickListeners && removeClickListeners(); // eslint-disable-line no-unused-expressions\n    removeClickListeners = undefined;\n  }\n\n  return {\n    didMount: function didMount(element, THREE, componentName) {\n\n      if (cache.length === 0) {\n        initialize(THREE, componentName);\n      }\n\n      if (cache.indexOf(element) === -1) {\n        cache.push(element);\n      }\n    },\n    didUnmount: function didUnmount(element) {\n\n      var cacheIndex = cache.indexOf(element);\n\n      removeDragListeners && removeDragListeners(); // eslint-disable-line no-unused-expressions\n      removeDragListeners = undefined;\n\n      if (cacheIndex === -1) {\n        return;\n      }\n\n      // remove that element\n      cache.splice(cacheIndex, 1);\n\n      if (cache.length === 0) {\n        tearDown();\n      }\n    }\n  };\n}(),\n    didMount = _ref10.didMount,\n    didUnmount = _ref10.didUnmount;\n\n/**\n * @param aframe {Object} The Aframe instance to register with\n * @param componentName {String} The component name to use. Default: 'click-drag'\n */\n\n\nfunction aframeDraggableComponent(aframe) {\n  var componentName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COMPONENT_NAME;\n\n\n  var THREE = aframe.THREE;\n\n  /**\n   * Draggable component for A-Frame.\n   */\n  aframe.registerComponent(componentName, {\n    schema: {},\n\n    /**\n     * Called once when component is attached. Generally for initial setup.\n     */\n    init: function init() {\n      didMount(this, THREE, componentName);\n    },\n\n\n    /**\n     * Called when component is attached and when component data changes.\n     * Generally modifies the entity based on the data.\n     *\n     * @param oldData\n     */\n    update: function update() {},\n\n\n    /**\n     * Called when a component is removed (e.g., via removeAttribute).\n     * Generally undoes all modifications to the entity.\n     */\n    remove: function remove() {\n      didUnmount(this);\n    },\n\n\n    /**\n     * Called when entity pauses.\n     * Use to stop or remove any dynamic or background behavior such as events.\n     */\n    pause: function pause() {\n      didUnmount(this);\n    },\n\n\n    /**\n     * Called when entity resumes.\n     * Use to continue or add any dynamic or background behavior such as events.\n     */\n    play: function play() {\n      didMount(this, THREE, componentName);\n    }\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZnJhbWUtY2xpY2stZHJhZy1jb21wb25lbnQvbGliL2luZGV4LmpzP2M2OWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFmcmFtZURyYWdnYWJsZUNvbXBvbmVudDtcblxudmFyIF9kZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBDT01QT05FTlRfTkFNRSA9ICdjbGljay1kcmFnJztcbnZhciBEUkFHX1NUQVJUX0VWRU5UID0gJ2RyYWdzdGFydCc7XG52YXIgRFJBR19NT1ZFX0VWRU5UID0gJ2RyYWdtb3ZlJztcbnZhciBEUkFHX0VORF9FVkVOVCA9ICdkcmFnZW5kJztcblxudmFyIFRJTUVfVE9fS0VFUF9MT0cgPSAxMDA7XG5cbmZ1bmN0aW9uIGZvcmNlV29ybGRVcGRhdGUodGhyZWVFbGVtZW50KSB7XG5cbiAgdmFyIGVsZW1lbnQgPSB0aHJlZUVsZW1lbnQ7XG4gIHdoaWxlIChlbGVtZW50LnBhcmVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgfVxuXG4gIGVsZW1lbnQudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hQYXJlbnQoZWxlbWVudCwgbGFtYmRhKSB7XG4gIHdoaWxlIChlbGVtZW50LmF0dGFjaGVkVG9QYXJlbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGxhbWJkYShlbGVtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzb21lUGFyZW50KGVsZW1lbnQsIGxhbWJkYSkge1xuICB3aGlsZSAoZWxlbWVudC5hdHRhY2hlZFRvUGFyZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAobGFtYmRhKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjYW1lcmFQb3NpdGlvblRvVmVjMyhjYW1lcmEsIHZlYzMpIHtcblxuICB2ZWMzLnNldChjYW1lcmEuY29tcG9uZW50cy5wb3NpdGlvbi5kYXRhLngsIGNhbWVyYS5jb21wb25lbnRzLnBvc2l0aW9uLmRhdGEueSwgY2FtZXJhLmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56KTtcblxuICBmb3JFYWNoUGFyZW50KGNhbWVyYSwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgIGlmIChlbGVtZW50LmNvbXBvbmVudHMgJiYgZWxlbWVudC5jb21wb25lbnRzLnBvc2l0aW9uKSB7XG4gICAgICB2ZWMzLnNldCh2ZWMzLnggKyBlbGVtZW50LmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS54LCB2ZWMzLnkgKyBlbGVtZW50LmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS55LCB2ZWMzLnogKyBlbGVtZW50LmNvbXBvbmVudHMucG9zaXRpb24uZGF0YS56KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2NhbFRvV29ybGQoVEhSRUUsIHRocmVlQ2FtZXJhLCB2ZWN0b3IpIHtcbiAgZm9yY2VXb3JsZFVwZGF0ZSh0aHJlZUNhbWVyYSk7XG4gIHJldHVybiB0aHJlZUNhbWVyYS5sb2NhbFRvV29ybGQodmVjdG9yKTtcbn1cblxudmFyIF9yZWYgPSBmdW5jdGlvbiB1bnByb2plY3RGdW5jdGlvbigpIHtcblxuICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICB2YXIgbWF0cml4ID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoVEhSRUUpIHtcbiAgICBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVucHJvamVjdDogZnVuY3Rpb24gdW5wcm9qZWN0KFRIUkVFLCB2ZWN0b3IsIGNhbWVyYSkge1xuXG4gICAgICB2YXIgdGhyZWVDYW1lcmEgPSBjYW1lcmEuY29tcG9uZW50cy5jYW1lcmEuY2FtZXJhO1xuXG4gICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxpemVkIHx8IGluaXRpYWxpemUoVEhSRUUpO1xuXG4gICAgICB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKG1hdHJpeC5nZXRJbnZlcnNlKHRocmVlQ2FtZXJhLnByb2plY3Rpb25NYXRyaXgpKTtcblxuICAgICAgcmV0dXJuIGxvY2FsVG9Xb3JsZChUSFJFRSwgdGhyZWVDYW1lcmEsIHZlY3Rvcik7XG4gICAgfVxuICB9O1xufSgpLFxuICAgIHVucHJvamVjdCA9IF9yZWYudW5wcm9qZWN0O1xuXG5mdW5jdGlvbiBjbGllbnRDb29yZHNUbzNEQ2FudmFzQ29vcmRzKGNsaWVudFgsIGNsaWVudFksIG9mZnNldFgsIG9mZnNldFksIGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAoY2xpZW50WCAtIG9mZnNldFgpIC8gY2xpZW50V2lkdGggKiAyIC0gMSxcbiAgICB5OiAtKChjbGllbnRZIC0gb2Zmc2V0WSkgLyBjbGllbnRIZWlnaHQpICogMiArIDFcbiAgfTtcbn1cblxudmFyIF9yZWYyID0gZnVuY3Rpb24gc2NyZWVuQ29vcmRzVG9EaXJlY3Rpb25GdW5jdGlvbigpIHtcblxuICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICB2YXIgbW91c2VQb3NBc1ZlYzMgPSB2b2lkIDA7XG4gIHZhciBjYW1lcmFQb3NBc1ZlYzMgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZShUSFJFRSkge1xuICAgIG1vdXNlUG9zQXNWZWMzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjYW1lcmFQb3NBc1ZlYzMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNjcmVlbkNvb3Jkc1RvRGlyZWN0aW9uOiBmdW5jdGlvbiBzY3JlZW5Db29yZHNUb0RpcmVjdGlvbihUSFJFRSwgYWZyYW1lQ2FtZXJhLCBfcmVmMykge1xuICAgICAgdmFyIGNsaWVudFggPSBfcmVmMy54LFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMy55O1xuXG5cbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbGl6ZWQgfHwgaW5pdGlhbGl6ZShUSFJFRSk7XG5cbiAgICAgIC8vIHNjYWxlIG1vdXNlIGNvb3JkaW5hdGVzIGRvd24gdG8gLTEgPC0+ICsxXG5cbiAgICAgIHZhciBfY2xpZW50Q29vcmRzVG8zRENhbnYgPSBjbGllbnRDb29yZHNUbzNEQ2FudmFzQ29vcmRzKGNsaWVudFgsIGNsaWVudFksIDAsIDAsIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBjYW52YXMgcG9zaXRpb25cbiAgICAgIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxuICAgICAgICAgIG1vdXNlWCA9IF9jbGllbnRDb29yZHNUbzNEQ2Fudi54LFxuICAgICAgICAgIG1vdXNlWSA9IF9jbGllbnRDb29yZHNUbzNEQ2Fudi55O1xuXG4gICAgICBtb3VzZVBvc0FzVmVjMy5zZXQobW91c2VYLCBtb3VzZVksIC0xKTtcblxuICAgICAgLy8gYXBwbHkgY2FtZXJhIHRyYW5zZm9ybWF0aW9uIGZyb20gbmVhci1wbGFuZSBvZiBtb3VzZSB4L3kgaW50byAzZCBzcGFjZVxuICAgICAgLy8gTk9URTogVGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBUSFJFRSBjb2RlIGRpcmVjdGx5IG9uY2UgdGhlIGFmcmFtZSBidWdcbiAgICAgIC8vIGlzIGZpeGVkOlxuICAgICAgLypcbiAgICAgICAgICAgIGNhbWVyYVBvc2l0aW9uVG9WZWMzKGFmcmFtZUNhbWVyYSwgY2FtZXJhUG9zQXNWZWMzKTtcbiAgICAgICAgICAgIGNvbnN0IHt4LCB5LCB6fSA9IG5ldyBUSFJFRVxuICAgICAgICAgICAgIC5WZWN0b3IzKG1vdXNlWCwgbW91c2VZLCAtMSlcbiAgICAgICAgICAgICAudW5wcm9qZWN0KGFmcmFtZUNhbWVyYS5jb21wb25lbnRzLmNhbWVyYS5jYW1lcmEpXG4gICAgICAgICAgICAgLnN1YihjYW1lcmFQb3NBc1ZlYzMpXG4gICAgICAgICAgICAgLm5vcm1hbGl6ZSgpO1xuICAgICAgKi9cbiAgICAgIHZhciBwcm9qZWN0ZWRWZWN0b3IgPSB1bnByb2plY3QoVEhSRUUsIG1vdXNlUG9zQXNWZWMzLCBhZnJhbWVDYW1lcmEpO1xuXG4gICAgICBjYW1lcmFQb3NpdGlvblRvVmVjMyhhZnJhbWVDYW1lcmEsIGNhbWVyYVBvc0FzVmVjMyk7XG5cbiAgICAgIC8vIEdldCB0aGUgdW5pdCBsZW5ndGggZGlyZWN0aW9uIHZlY3RvciBmcm9tIHRoZSBjYW1lcmEncyBwb3NpdGlvblxuXG4gICAgICB2YXIgX3Byb2plY3RlZFZlY3RvciRzdWIkID0gcHJvamVjdGVkVmVjdG9yLnN1YihjYW1lcmFQb3NBc1ZlYzMpLm5vcm1hbGl6ZSgpLFxuICAgICAgICAgIHggPSBfcHJvamVjdGVkVmVjdG9yJHN1YiQueCxcbiAgICAgICAgICB5ID0gX3Byb2plY3RlZFZlY3RvciRzdWIkLnksXG4gICAgICAgICAgeiA9IF9wcm9qZWN0ZWRWZWN0b3Ikc3ViJC56O1xuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07XG4gICAgfVxuICB9O1xufSgpLFxuICAgIHNjcmVlbkNvb3Jkc1RvRGlyZWN0aW9uID0gX3JlZjIuc2NyZWVuQ29vcmRzVG9EaXJlY3Rpb247XG5cbi8qKlxuICogQHBhcmFtIHBsYW5lTm9ybWFsIHtUSFJFRS5WZWN0b3IzfVxuICogQHBhcmFtIHBsYW5lQ29uc3RhbnQge0Zsb2F0fSBEaXN0YW5jZSBmcm9tIG9yaWdpbiBvZiB0aGUgcGxhbmVcbiAqIEBwYXJhbSByYXlEaXJlY3Rpb24ge1RIUkVFLlZlY3RvcjN9IERpcmVjdGlvbiBvZiByYXkgZnJvbSB0aGUgb3JpZ2luXG4gKlxuICogQHJldHVybiB7VEhSRUUuVmVjdG9yM30gVGhlIGludGVyc2VjdGlvbiBwb2ludCBvZiB0aGUgcmF5IGFuZCBwbGFuZVxuICovXG5cblxuZnVuY3Rpb24gcmF5UGxhbmVJbnRlcnNlY3Rpb24ocGxhbmVOb3JtYWwsIHBsYW5lQ29uc3RhbnQsIHJheURpcmVjdGlvbikge1xuICAvLyBBIGxpbmUgZnJvbSB0aGUgY2FtZXJhIHBvc2l0aW9uIHRvd2FyZCAoYW5kIHRocm91Z2gpIHRoZSBwbGFuZVxuICB2YXIgZGlzdGFuY2VUb1BsYW5lID0gcGxhbmVDb25zdGFudCAvIHBsYW5lTm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pO1xuICByZXR1cm4gcmF5RGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKGRpc3RhbmNlVG9QbGFuZSk7XG59XG5cbnZhciBfcmVmNCA9IGZ1bmN0aW9uIGRpcmVjdGlvblRvV29ybGRDb29yZHNGdW5jdGlvbigpIHtcblxuICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICB2YXIgZGlyZWN0aW9uID0gdm9pZCAwO1xuICB2YXIgY2FtZXJhUG9zQXNWZWMzID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoVEhSRUUpIHtcbiAgICBkaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNhbWVyYVBvc0FzVmVjMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNhbWVyYSBUaHJlZS5qcyBDYW1lcmEgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gT2JqZWN0IFBvc2l0aW9uIG9mIHRoZSBjYW1lcmFcbiAgICAgKiBAcGFyYW0gT2JqZWN0IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSAoc2NhbGVkIHRvIGJlIGJldHdlZW4gLTEgdG8gMSlcbiAgICAgKiBAcGFyYW0gZGVwdGggRGVwdGggaW50byB0aGUgc2NyZWVuIHRvIGNhbGN1bGF0ZSB3b3JsZCBjb29yZGluYXRlcyBmb3JcbiAgICAgKi9cbiAgICBkaXJlY3Rpb25Ub1dvcmxkQ29vcmRzOiBmdW5jdGlvbiBkaXJlY3Rpb25Ub1dvcmxkQ29vcmRzKFRIUkVFLCBhZnJhbWVDYW1lcmEsIGNhbWVyYSwgX3JlZjUsIGRlcHRoKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uWCA9IF9yZWY1LngsXG4gICAgICAgICAgZGlyZWN0aW9uWSA9IF9yZWY1LnksXG4gICAgICAgICAgZGlyZWN0aW9uWiA9IF9yZWY1Lno7XG5cblxuICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsaXplZCB8fCBpbml0aWFsaXplKFRIUkVFKTtcblxuICAgICAgY2FtZXJhUG9zaXRpb25Ub1ZlYzMoYWZyYW1lQ2FtZXJhLCBjYW1lcmFQb3NBc1ZlYzMpO1xuICAgICAgZGlyZWN0aW9uLnNldChkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZLCBkaXJlY3Rpb25aKTtcblxuICAgICAgLy8gQSBsaW5lIGZyb20gdGhlIGNhbWVyYSBwb3NpdGlvbiB0b3dhcmQgKGFuZCB0aHJvdWdoKSB0aGUgcGxhbmVcbiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHJheVBsYW5lSW50ZXJzZWN0aW9uKGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbigpLCBkZXB0aCwgZGlyZWN0aW9uKTtcblxuICAgICAgLy8gUmVwb3NpdGlvbiBiYWNrIHRvIHRoZSBjYW1lcmEgcG9zaXRpb25cblxuICAgICAgdmFyIF9uZXdQb3NpdGlvbiRhZGQgPSBuZXdQb3NpdGlvbi5hZGQoY2FtZXJhUG9zQXNWZWMzKSxcbiAgICAgICAgICB4ID0gX25ld1Bvc2l0aW9uJGFkZC54LFxuICAgICAgICAgIHkgPSBfbmV3UG9zaXRpb24kYWRkLnksXG4gICAgICAgICAgeiA9IF9uZXdQb3NpdGlvbiRhZGQuejtcblxuICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgejogeiB9O1xuICAgIH1cbiAgfTtcbn0oKSxcbiAgICBkaXJlY3Rpb25Ub1dvcmxkQ29vcmRzID0gX3JlZjQuZGlyZWN0aW9uVG9Xb3JsZENvb3JkcztcblxudmFyIF9yZWY2ID0gZnVuY3Rpb24gc2VsZWN0SXRlbUZ1bmN0aW9uKCkge1xuXG4gIHZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gIHZhciBjYW1lcmFQb3NBc1ZlYzMgPSB2b2lkIDA7XG4gIHZhciBkaXJlY3Rpb25Bc1ZlYzMgPSB2b2lkIDA7XG4gIHZhciByYXljYXN0ZXIgPSB2b2lkIDA7XG4gIHZhciBwbGFuZSA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBpbml0aWFsaXplKFRIUkVFKSB7XG4gICAgcGxhbmUgPSBuZXcgVEhSRUUuUGxhbmUoKTtcbiAgICBjYW1lcmFQb3NBc1ZlYzMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGRpcmVjdGlvbkFzVmVjMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuXG4gICAgLy8gVE9ETzogRnJvbSBjYW1lcmEgdmFsdWVzP1xuICAgIHJheWNhc3Rlci5mYXIgPSBJbmZpbml0eTtcbiAgICByYXljYXN0ZXIubmVhciA9IDA7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VsZWN0SXRlbTogZnVuY3Rpb24gc2VsZWN0SXRlbShUSFJFRSwgc2VsZWN0b3IsIGNhbWVyYSwgY2xpZW50WCwgY2xpZW50WSkge1xuXG4gICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxpemVkIHx8IGluaXRpYWxpemUoVEhSRUUpO1xuXG4gICAgICB2YXIgX3NjcmVlbkNvb3Jkc1RvRGlyZWN0ID0gc2NyZWVuQ29vcmRzVG9EaXJlY3Rpb24oVEhSRUUsIGNhbWVyYSwgeyB4OiBjbGllbnRYLCB5OiBjbGllbnRZIH0pLFxuICAgICAgICAgIGRpcmVjdGlvblggPSBfc2NyZWVuQ29vcmRzVG9EaXJlY3QueCxcbiAgICAgICAgICBkaXJlY3Rpb25ZID0gX3NjcmVlbkNvb3Jkc1RvRGlyZWN0LnksXG4gICAgICAgICAgZGlyZWN0aW9uWiA9IF9zY3JlZW5Db29yZHNUb0RpcmVjdC56O1xuXG4gICAgICBjYW1lcmFQb3NpdGlvblRvVmVjMyhjYW1lcmEsIGNhbWVyYVBvc0FzVmVjMyk7XG4gICAgICBkaXJlY3Rpb25Bc1ZlYzMuc2V0KGRpcmVjdGlvblgsIGRpcmVjdGlvblksIGRpcmVjdGlvblopO1xuXG4gICAgICByYXljYXN0ZXIuc2V0KGNhbWVyYVBvc0FzVmVjMywgZGlyZWN0aW9uQXNWZWMzKTtcblxuICAgICAgLy8gUHVzaCBtZXNoZXMgb250byBsaXN0IG9mIG9iamVjdHMgdG8gaW50ZXJzZWN0LlxuICAgICAgLy8gVE9ETzogQ2FuIHdlIGRvIHRoaXMgYXQgc29tZSBvdGhlciBwb2ludCBpbnN0ZWFkIG9mIGV2ZXJ5IHRpbWUgYSByYXkgaXNcbiAgICAgIC8vIGNhc3Q/IElzIHRoYXQgYSBtaWNybyBvcHRpbWl6YXRpb24/XG4gICAgICB2YXIgb2JqZWN0cyA9IEFycmF5LmZyb20oY2FtZXJhLnNjZW5lRWwucXVlcnlTZWxlY3RvckFsbCgnWycgKyBzZWxlY3RvciArICddJykpLm1hcChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Qub2JqZWN0M0Q7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IHRydWU7XG5cbiAgICAgIHZhciBpbnRlcnNlY3RlZCA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKG9iamVjdHMsIHJlY3Vyc2l2ZSlcbiAgICAgIC8vIE9ubHkga2VlcCBpbnRlcnNlY3Rpb25zIGFnYWluc3Qgb2JqZWN0cyB0aGF0IGhhdmUgYSByZWZlcmVuY2UgdG8gYW4gZW50aXR5LlxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhIWludGVyc2VjdGlvbi5vYmplY3QuZWw7XG4gICAgICB9KVxuICAgICAgLy8gT25seSBrZWVwIG9uZXMgdGhhdCBhcmUgdmlzaWJsZVxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24ub2JqZWN0LnBhcmVudC52aXNpYmxlO1xuICAgICAgfSlcbiAgICAgIC8vIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBjbG9zZXN0XG4gICAgICBbMF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmVcblxuICAgICAgaWYgKCFpbnRlcnNlY3RlZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IGludGVyc2VjdGVkLnBvaW50LFxuICAgICAgICAgIG9iamVjdCA9IGludGVyc2VjdGVkLm9iamVjdDtcblxuICAgICAgLy8gQWxpZ25lZCB0byB0aGUgd29ybGQgZGlyZWN0aW9uIG9mIHRoZSBjYW1lcmFcbiAgICAgIC8vIEF0IHRoZSBzcGVjaWZpZWQgaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgIHBsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KGNhbWVyYS5jb21wb25lbnRzLmNhbWVyYS5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oKS5jbG9uZSgpLm5lZ2F0ZSgpLCBwb2ludC5jbG9uZSgpLnN1YihjYW1lcmFQb3NBc1ZlYzMpKTtcblxuICAgICAgdmFyIGRlcHRoID0gcGxhbmUuY29uc3RhbnQ7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBwb2ludC5zdWIob2JqZWN0LmdldFdvcmxkUG9zaXRpb24oKSk7XG5cbiAgICAgIHJldHVybiB7IGRlcHRoOiBkZXB0aCwgb2Zmc2V0OiBvZmZzZXQsIGVsZW1lbnQ6IG9iamVjdC5lbCB9O1xuICAgIH1cbiAgfTtcbn0oKSxcbiAgICBzZWxlY3RJdGVtID0gX3JlZjYuc2VsZWN0SXRlbTtcblxuZnVuY3Rpb24gZHJhZ0l0ZW0oVEhSRUUsIGVsZW1lbnQsIG9mZnNldCwgY2FtZXJhLCBkZXB0aCwgbW91c2VJbmZvKSB7XG5cbiAgdmFyIHRocmVlQ2FtZXJhID0gY2FtZXJhLmNvbXBvbmVudHMuY2FtZXJhLmNhbWVyYTtcblxuICAvLyBTZXR0aW5nIHVwIGZvciByb3RhdGlvbiBjYWxjdWxhdGlvbnNcbiAgdmFyIHN0YXJ0Q2FtZXJhUm90YXRpb25JbnZlcnNlID0gdGhyZWVDYW1lcmEuZ2V0V29ybGRRdWF0ZXJuaW9uKCkuaW52ZXJzZSgpO1xuICB2YXIgc3RhcnRFbGVtZW50Um90YXRpb24gPSBlbGVtZW50Lm9iamVjdDNELmdldFdvcmxkUXVhdGVybmlvbigpO1xuICB2YXIgZWxlbWVudFJvdGF0aW9uT3JkZXIgPSBlbGVtZW50Lm9iamVjdDNELnJvdGF0aW9uLm9yZGVyO1xuXG4gIHZhciByb3RhdGlvblF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB2YXIgcm90YXRpb25FdWxlciA9IGVsZW1lbnQub2JqZWN0M0Qucm90YXRpb24uY2xvbmUoKTtcblxuICB2YXIgb2Zmc2V0VmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMob2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueik7XG4gIHZhciBsYXN0TW91c2VJbmZvID0gbW91c2VJbmZvO1xuXG4gIHZhciBuZXh0Um90YXRpb24gPSB7XG4gICAgeDogVEhSRUUuTWF0aC5yYWRUb0RlZyhyb3RhdGlvbkV1bGVyLngpLFxuICAgIHk6IFRIUkVFLk1hdGgucmFkVG9EZWcocm90YXRpb25FdWxlci55KSxcbiAgICB6OiBUSFJFRS5NYXRoLnJhZFRvRGVnKHJvdGF0aW9uRXVsZXIueilcbiAgfTtcblxuICB2YXIgYWN0aXZlQ2FtZXJhID0gZWxlbWVudC5zY2VuZUVsLnN5c3RlbXMuY2FtZXJhLmFjdGl2ZUNhbWVyYUVsO1xuXG4gIHZhciBpc0NoaWxkT2ZBY3RpdmVDYW1lcmEgPSBzb21lUGFyZW50KGVsZW1lbnQsIGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50ID09PSBhY3RpdmVDYW1lcmE7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKF9yZWY3KSB7XG4gICAgdmFyIGNsaWVudFggPSBfcmVmNy5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gX3JlZjcuY2xpZW50WTtcblxuXG4gICAgbGFzdE1vdXNlSW5mbyA9IHsgY2xpZW50WDogY2xpZW50WCwgY2xpZW50WTogY2xpZW50WSB9O1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IHNjcmVlbkNvb3Jkc1RvRGlyZWN0aW9uKFRIUkVFLCBjYW1lcmEsIHsgeDogY2xpZW50WCwgeTogY2xpZW50WSB9KTtcblxuICAgIHZhciBfZGlyZWN0aW9uVG9Xb3JsZENvb3IgPSBkaXJlY3Rpb25Ub1dvcmxkQ29vcmRzKFRIUkVFLCBjYW1lcmEsIGNhbWVyYS5jb21wb25lbnRzLmNhbWVyYS5jYW1lcmEsIGRpcmVjdGlvbiwgZGVwdGgpLFxuICAgICAgICB4ID0gX2RpcmVjdGlvblRvV29ybGRDb29yLngsXG4gICAgICAgIHkgPSBfZGlyZWN0aW9uVG9Xb3JsZENvb3IueSxcbiAgICAgICAgeiA9IF9kaXJlY3Rpb25Ub1dvcmxkQ29vci56O1xuXG4gICAgdmFyIHJvdGF0aW9uRGlmZiA9IHZvaWQgMDtcblxuICAgIC8vIFN0YXJ0IGJ5IHJvdGF0aW5nIGJhY2t3YXJkcyBmcm9tIHRoZSBpbml0aWFsIGNhbWVyYSByb3RhdGlvblxuICAgIHJvdGF0aW9uRGlmZiA9IHJvdGF0aW9uUXVhdGVybmlvbi5jb3B5KHN0YXJ0Q2FtZXJhUm90YXRpb25JbnZlcnNlKTtcblxuICAgIC8vIHJvdGF0ZSB0aGUgb2Zmc2V0XG4gICAgb2Zmc2V0VmVjdG9yLnNldChvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56KTtcblxuICAgIC8vIFRoZW4gYWRkIHRoZSBjdXJyZW50IGNhbWVyYSByb3RhdGlvblxuICAgIHJvdGF0aW9uRGlmZiA9IHJvdGF0aW9uUXVhdGVybmlvbi5tdWx0aXBseSh0aHJlZUNhbWVyYS5nZXRXb3JsZFF1YXRlcm5pb24oKSk7XG5cbiAgICBvZmZzZXRWZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKHJvdGF0aW9uRGlmZik7XG5cbiAgICBpZiAoIWlzQ2hpbGRPZkFjdGl2ZUNhbWVyYSkge1xuICAgICAgLy8gQW5kIGNvcnJlY3RseSBvZmZzZXQgcm90YXRpb25cbiAgICAgIHJvdGF0aW9uRGlmZi5tdWx0aXBseShzdGFydEVsZW1lbnRSb3RhdGlvbik7XG5cbiAgICAgIHJvdGF0aW9uRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24ocm90YXRpb25EaWZmLCBlbGVtZW50Um90YXRpb25PcmRlcik7XG4gICAgfVxuXG4gICAgbmV4dFJvdGF0aW9uLnggPSBUSFJFRS5NYXRoLnJhZFRvRGVnKHJvdGF0aW9uRXVsZXIueCk7XG4gICAgbmV4dFJvdGF0aW9uLnkgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKHJvdGF0aW9uRXVsZXIueSk7XG4gICAgbmV4dFJvdGF0aW9uLnogPSBUSFJFRS5NYXRoLnJhZFRvRGVnKHJvdGF0aW9uRXVsZXIueik7XG5cbiAgICB2YXIgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gb2Zmc2V0VmVjdG9yLngsIHk6IHkgLSBvZmZzZXRWZWN0b3IueSwgejogeiAtIG9mZnNldFZlY3Rvci56IH07XG5cbiAgICAvLyBXaGVuIHRoZSBlbGVtZW50IGhhcyBwYXJlbnRzLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXRzIG5ldyB3b3JsZCBwb3NpdGlvblxuICAgIC8vIGludG8gbmV3IGxvY2FsIHBvc2l0aW9uIG9mIGl0cyBwYXJlbnQgZWxlbWVudFxuICAgIGlmIChlbGVtZW50LnBhcmVudEVsICE9PSBlbGVtZW50LnNjZW5lRWwpIHtcblxuICAgICAgLy8gVGhlIG5ldyB3b3JsZCBwb3NpdGlvblxuICAgICAgb2Zmc2V0VmVjdG9yLnNldChuZXh0UG9zaXRpb24ueCwgbmV4dFBvc2l0aW9uLnksIG5leHRQb3NpdGlvbi56KTtcblxuICAgICAgLy8gQ29udmVydGVkXG4gICAgICBlbGVtZW50LnBhcmVudEVsLm9iamVjdDNELndvcmxkVG9Mb2NhbChvZmZzZXRWZWN0b3IpO1xuXG4gICAgICBuZXh0UG9zaXRpb24ueCA9IG9mZnNldFZlY3Rvci54O1xuICAgICAgbmV4dFBvc2l0aW9uLnkgPSBvZmZzZXRWZWN0b3IueTtcbiAgICAgIG5leHRQb3NpdGlvbi56ID0gb2Zmc2V0VmVjdG9yLno7XG4gICAgfVxuXG4gICAgZWxlbWVudC5lbWl0KERSQUdfTU9WRV9FVkVOVCwgeyBuZXh0UG9zaXRpb246IG5leHRQb3NpdGlvbiwgbmV4dFJvdGF0aW9uOiBuZXh0Um90YXRpb24sIGNsaWVudFg6IGNsaWVudFgsIGNsaWVudFk6IGNsaWVudFkgfSk7XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXh0UG9zaXRpb24pO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJywgbmV4dFJvdGF0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKF9yZWY4KSB7XG4gICAgdmFyIF9yZWY4JGNoYW5nZWRUb3VjaGVzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjguY2hhbmdlZFRvdWNoZXMsIDEpLFxuICAgICAgICB0b3VjaEluZm8gPSBfcmVmOCRjaGFuZ2VkVG91Y2hlc1swXTtcblxuICAgIG9uTW91c2VNb3ZlKHRvdWNoSW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNhbWVyYUNoYW5nZShfcmVmOSkge1xuICAgIHZhciBkZXRhaWwgPSBfcmVmOS5kZXRhaWw7XG5cbiAgICBpZiAoKGRldGFpbC5uYW1lID09PSAncG9zaXRpb24nIHx8IGRldGFpbC5uYW1lID09PSAncm90YXRpb24nKSAmJiAhKDAsIF9kZWVwRXF1YWwyLmRlZmF1bHQpKGRldGFpbC5vbGREYXRhLCBkZXRhaWwubmV3RGF0YSkpIHtcbiAgICAgIG9uTW91c2VNb3ZlKGxhc3RNb3VzZUluZm8pO1xuICAgIH1cbiAgfVxuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICBjYW1lcmEuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9uZW50Y2hhbmdlZCcsIG9uQ2FtZXJhQ2hhbmdlKTtcblxuICAvLyBUaGUgXCJ1bmxpc3RlblwiIGZ1bmN0aW9uXG4gIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgY2FtZXJhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBvbmVudGNoYW5nZWQnLCBvbkNhbWVyYUNoYW5nZSk7XG4gIH07XG59XG5cbi8vIENsb3N1cmUgdG8gY2xvc2Ugb3ZlciB0aGUgcmVtb3ZhbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cbnZhciBfcmVmMTAgPSBmdW5jdGlvbiBnZXREaWRNb3VudEFuZFVubW91bnQoKSB7XG5cbiAgdmFyIHJlbW92ZUNsaWNrTGlzdGVuZXJzID0gdm9pZCAwO1xuICB2YXIgcmVtb3ZlRHJhZ0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgdmFyIGNhY2hlID0gW107XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZShUSFJFRSwgY29tcG9uZW50TmFtZSkge1xuXG4gICAgLy8gVE9ETzogQmFzZWQgb24gYSBzY2VuZSBmcm9tIHRoZSBlbGVtZW50IHBhc3NlZCBpbj9cbiAgICB2YXIgc2NlbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdhLXNjZW5lJyk7XG4gICAgLy8gZGVsYXkgbG9hZGluZyBvZiB0aGlzIGFzIHdlJ3JlIG5vdCAxMDAlIGlmIHRoZSBzY2VuZSBoYXMgbG9hZGVkIHlldCBvciBub3RcbiAgICB2YXIgY2FtZXJhID0gdm9pZCAwO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudCA9IHZvaWQgMDtcbiAgICB2YXIgZHJhZ0luZm8gPSB2b2lkIDA7XG4gICAgdmFyIHBvc2l0aW9uTG9nID0gW107XG5cbiAgICBmdW5jdGlvbiBjbGVhblVwUG9zaXRpb25Mb2coKSB7XG4gICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB3aGlsZSAocG9zaXRpb25Mb2cubGVuZ3RoICYmIG5vdyAtIHBvc2l0aW9uTG9nWzBdLnRpbWUgPiBUSU1FX1RPX0tFRVBfTE9HKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudDtcbiAgICAgICAgcG9zaXRpb25Mb2cuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdnZWQoX3JlZjExKSB7XG4gICAgICB2YXIgbmV4dFBvc2l0aW9uID0gX3JlZjExLmRldGFpbC5uZXh0UG9zaXRpb247XG5cbiAgICAgIC8vIENvbnRpbnVvdXNseSBjbGVhbiB1cCBzbyB3ZSBkb24ndCBnZXQgaHVnZSBsb2dzIGJ1aWx0IHVwXG4gICAgICBjbGVhblVwUG9zaXRpb25Mb2coKTtcbiAgICAgIHBvc2l0aW9uTG9nLnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgbmV4dFBvc2l0aW9uKSxcbiAgICAgICAgdGltZTogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKF9yZWYxMikge1xuICAgICAgdmFyIGNsaWVudFggPSBfcmVmMTIuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjEyLmNsaWVudFk7XG5cbiAgICAgIHZhciBfc2VsZWN0SXRlbSA9IHNlbGVjdEl0ZW0oVEhSRUUsIGNvbXBvbmVudE5hbWUsIGNhbWVyYSwgY2xpZW50WCwgY2xpZW50WSksXG4gICAgICAgICAgZGVwdGggPSBfc2VsZWN0SXRlbS5kZXB0aCxcbiAgICAgICAgICBvZmZzZXQgPSBfc2VsZWN0SXRlbS5vZmZzZXQsXG4gICAgICAgICAgZWxlbWVudCA9IF9zZWxlY3RJdGVtLmVsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQ2FuIG9ubHkgZHJhZyBvbmUgaXRlbSBhdCBhIHRpbWUsIHNvIG5vIG5lZWQgdG8gY2hlY2sgaWYgYW55XG4gICAgICAgICAgLy8gbGlzdGVuZXIgaXMgYWxyZWFkeSBzZXQgdXBcbiAgICAgICAgICB2YXIgcmVtb3ZlRHJhZ0l0ZW1MaXN0ZW5lcnMgPSBkcmFnSXRlbShUSFJFRSwgZWxlbWVudCwgb2Zmc2V0LCBjYW1lcmEsIGRlcHRoLCB7XG4gICAgICAgICAgICBjbGllbnRYOiBjbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogY2xpZW50WVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZHJhZ2dlZEVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgICAgZHJhZ0luZm8gPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IHsgeDogb2Zmc2V0LngsIHk6IG9mZnNldC55LCB6OiBvZmZzZXQueiB9LFxuICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGNsaWVudFlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKERSQUdfTU9WRV9FVkVOVCwgb25EcmFnZ2VkKTtcblxuICAgICAgICAgIHJlbW92ZURyYWdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVEcmFnTGlzdGVuZXJzKF8pIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihEUkFHX01PVkVfRVZFTlQsIG9uRHJhZ2dlZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAgICAgICByZW1vdmVEcmFnSXRlbUxpc3RlbmVycyAmJiByZW1vdmVEcmFnSXRlbUxpc3RlbmVycygpO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGlzIHJlbW92YWwgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgIHJlbW92ZURyYWdJdGVtTGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZWxlbWVudC5lbWl0KERSQUdfU1RBUlRfRVZFTlQsIGRyYWdJbmZvKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVWZWxvY2l0eSgpIHtcblxuICAgICAgaWYgKHBvc2l0aW9uTG9nLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydCA9IHBvc2l0aW9uTG9nW3Bvc2l0aW9uTG9nLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uTG9nWzBdO1xuXG4gICAgICB2YXIgZGVsdGFUaW1lID0gMTAwMCAvIChzdGFydC50aW1lIC0gZW5kLnRpbWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKHN0YXJ0LnBvc2l0aW9uLnggLSBlbmQucG9zaXRpb24ueCkgKiBkZWx0YVRpbWUsIC8vIG0vc1xuICAgICAgICB5OiAoc3RhcnQucG9zaXRpb24ueSAtIGVuZC5wb3NpdGlvbi55KSAqIGRlbHRhVGltZSwgLy8gbS9zXG4gICAgICAgIHo6IChzdGFydC5wb3NpdGlvbi56IC0gZW5kLnBvc2l0aW9uLnopICogZGVsdGFUaW1lIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKF9yZWYxMykge1xuICAgICAgdmFyIGNsaWVudFggPSBfcmVmMTMuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjEzLmNsaWVudFk7XG5cblxuICAgICAgaWYgKCFkcmFnZ2VkRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFuVXBQb3NpdGlvbkxvZygpO1xuXG4gICAgICB2YXIgdmVsb2NpdHkgPSBjYWxjdWxhdGVWZWxvY2l0eSgpO1xuXG4gICAgICBkcmFnZ2VkRWxlbWVudC5lbWl0KERSQUdfRU5EX0VWRU5ULCBPYmplY3QuYXNzaWduKHt9LCBkcmFnSW5mbywgeyBjbGllbnRYOiBjbGllbnRYLCBjbGllbnRZOiBjbGllbnRZLCB2ZWxvY2l0eTogdmVsb2NpdHkgfSkpO1xuXG4gICAgICByZW1vdmVEcmFnTGlzdGVuZXJzICYmIHJlbW92ZURyYWdMaXN0ZW5lcnMoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIHJlbW92ZURyYWdMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KF9yZWYxNCkge1xuICAgICAgdmFyIF9yZWYxNCRjaGFuZ2VkVG91Y2hlcyA9IF9zbGljZWRUb0FycmF5KF9yZWYxNC5jaGFuZ2VkVG91Y2hlcywgMSksXG4gICAgICAgICAgdG91Y2hJbmZvID0gX3JlZjE0JGNoYW5nZWRUb3VjaGVzWzBdO1xuXG4gICAgICBvbk1vdXNlRG93bih0b3VjaEluZm8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoX3JlZjE1KSB7XG4gICAgICB2YXIgX3JlZjE1JGNoYW5nZWRUb3VjaGVzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LmNoYW5nZWRUb3VjaGVzLCAxKSxcbiAgICAgICAgICB0b3VjaEluZm8gPSBfcmVmMTUkY2hhbmdlZFRvdWNoZXNbMF07XG5cbiAgICAgIG9uTW91c2VVcCh0b3VjaEluZm8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcblxuICAgICAgY2FtZXJhID0gc2NlbmUuY2FtZXJhLmVsO1xuXG4gICAgICAvLyBUT0RPOiBBdHRhY2ggdG8gY2FudmFzP1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcblxuICAgICAgcmVtb3ZlQ2xpY2tMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVDbGlja0xpc3RlbmVycyhfKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzY2VuZS5oYXNMb2FkZWQpIHtcbiAgICAgIHJ1bigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBydW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRlYXJEb3duKCkge1xuICAgIHJlbW92ZUNsaWNrTGlzdGVuZXJzICYmIHJlbW92ZUNsaWNrTGlzdGVuZXJzKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgcmVtb3ZlQ2xpY2tMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpZE1vdW50OiBmdW5jdGlvbiBkaWRNb3VudChlbGVtZW50LCBUSFJFRSwgY29tcG9uZW50TmFtZSkge1xuXG4gICAgICBpZiAoY2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluaXRpYWxpemUoVEhSRUUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FjaGUuaW5kZXhPZihlbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgY2FjaGUucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZFVubW91bnQ6IGZ1bmN0aW9uIGRpZFVubW91bnQoZWxlbWVudCkge1xuXG4gICAgICB2YXIgY2FjaGVJbmRleCA9IGNhY2hlLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgICAgIHJlbW92ZURyYWdMaXN0ZW5lcnMgJiYgcmVtb3ZlRHJhZ0xpc3RlbmVycygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgcmVtb3ZlRHJhZ0xpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGNhY2hlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRoYXQgZWxlbWVudFxuICAgICAgY2FjaGUuc3BsaWNlKGNhY2hlSW5kZXgsIDEpO1xuXG4gICAgICBpZiAoY2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRlYXJEb3duKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSgpLFxuICAgIGRpZE1vdW50ID0gX3JlZjEwLmRpZE1vdW50LFxuICAgIGRpZFVubW91bnQgPSBfcmVmMTAuZGlkVW5tb3VudDtcblxuLyoqXG4gKiBAcGFyYW0gYWZyYW1lIHtPYmplY3R9IFRoZSBBZnJhbWUgaW5zdGFuY2UgdG8gcmVnaXN0ZXIgd2l0aFxuICogQHBhcmFtIGNvbXBvbmVudE5hbWUge1N0cmluZ30gVGhlIGNvbXBvbmVudCBuYW1lIHRvIHVzZS4gRGVmYXVsdDogJ2NsaWNrLWRyYWcnXG4gKi9cblxuXG5mdW5jdGlvbiBhZnJhbWVEcmFnZ2FibGVDb21wb25lbnQoYWZyYW1lKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDT01QT05FTlRfTkFNRTtcblxuXG4gIHZhciBUSFJFRSA9IGFmcmFtZS5USFJFRTtcblxuICAvKipcbiAgICogRHJhZ2dhYmxlIGNvbXBvbmVudCBmb3IgQS1GcmFtZS5cbiAgICovXG4gIGFmcmFtZS5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnROYW1lLCB7XG4gICAgc2NoZW1hOiB7fSxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbmNlIHdoZW4gY29tcG9uZW50IGlzIGF0dGFjaGVkLiBHZW5lcmFsbHkgZm9yIGluaXRpYWwgc2V0dXAuXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGRpZE1vdW50KHRoaXMsIFRIUkVFLCBjb21wb25lbnROYW1lKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjb21wb25lbnQgaXMgYXR0YWNoZWQgYW5kIHdoZW4gY29tcG9uZW50IGRhdGEgY2hhbmdlcy5cbiAgICAgKiBHZW5lcmFsbHkgbW9kaWZpZXMgdGhlIGVudGl0eSBiYXNlZCBvbiB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvbGREYXRhXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVtb3ZlZCAoZS5nLiwgdmlhIHJlbW92ZUF0dHJpYnV0ZSkuXG4gICAgICogR2VuZXJhbGx5IHVuZG9lcyBhbGwgbW9kaWZpY2F0aW9ucyB0byB0aGUgZW50aXR5LlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgZGlkVW5tb3VudCh0aGlzKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBlbnRpdHkgcGF1c2VzLlxuICAgICAqIFVzZSB0byBzdG9wIG9yIHJlbW92ZSBhbnkgZHluYW1pYyBvciBiYWNrZ3JvdW5kIGJlaGF2aW9yIHN1Y2ggYXMgZXZlbnRzLlxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIGRpZFVubW91bnQodGhpcyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gZW50aXR5IHJlc3VtZXMuXG4gICAgICogVXNlIHRvIGNvbnRpbnVlIG9yIGFkZCBhbnkgZHluYW1pYyBvciBiYWNrZ3JvdW5kIGJlaGF2aW9yIHN1Y2ggYXMgZXZlbnRzLlxuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICBkaWRNb3VudCh0aGlzLCBUSFJFRSwgY29tcG9uZW50TmFtZSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FmcmFtZS1jbGljay1kcmFnLWNvbXBvbmVudC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(/*! ./lib/keys.js */ 3);\nvar isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ 4);\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzPzg2NWMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzPzU4ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanM/OWZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ })
/******/ ]);